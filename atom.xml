<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.geekore.ink</id>
    <title>KainHao的博客</title>
    <updated>2021-02-22T08:20:28.647Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.geekore.ink"/>
    <link rel="self" href="https://www.geekore.ink/atom.xml"/>
    <subtitle>一只咸鱼的博客</subtitle>
    <logo>https://www.geekore.ink/images/avatar.png</logo>
    <icon>https://www.geekore.ink/favicon.ico</icon>
    <rights>All rights reserved 2021, KainHao的博客</rights>
    <entry>
        <title type="html"><![CDATA[Python json库]]></title>
        <id>https://www.geekore.ink/python-json/</id>
        <link href="https://www.geekore.ink/python-json/">
        </link>
        <updated>2021-02-12T10:04:05.000Z</updated>
        <content type="html"><![CDATA[<p>来介绍下Python中自带的一个库: json</p>
<hr>
<h1 id="引入">引入</h1>
<p>在你安装Python时json应已经被安装</p>
<pre><code class="language-python">import json
</code></pre>
<h1 id="编码">编码:</h1>
<p>语法:</p>
<pre><code class="language-python">json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)
</code></pre>
<p>实例:</p>
<pre><code class="language-python">import json

dataRaw = [ {'a':1,'b':2}]

data = json.dumps(dataRaw)
print(data)
</code></pre>
<h1 id="解码">解码</h1>
<p>语法:</p>
<pre><code class="language-python">json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])
</code></pre>
<p>实例:</p>
<pre><code class="language-python">import json

dataRaw = '{&quot;a&quot;:1,&quot;b&quot;:2}'

data = json.loads(dataRaw)
print(data)
</code></pre>
<hr>
<p>你还可以使用<code>json.load</code>和<code>json.dump</code>来处理和JSON相关的文件.</p>
<p><s>今日水文+1,不想写了就这样吧</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js初探]]></title>
        <id>https://www.geekore.ink/nodejs-1/</id>
        <link href="https://www.geekore.ink/nodejs-1/">
        </link>
        <updated>2021-02-12T09:59:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>Node.js,顾名思义,是基于Chrome V8引擎的异步/非阻塞JavaScript运行环境(解析器).<br>
讲简单点就是跑在服务器端的JavaScript.</p>
<hr>
<h1 id="0x01-安装与repl使用">0x01 安装与REPL使用</h1>
<h2 id="1-安装">.1 安装</h2>
<h3 id="linux下安装">Linux下安装</h3>
<p>用自带的包管理器安装即可.<br>
这里以Ubuntu 20.04 LTS为例:</p>
<pre><code class="language-bash">apt install nodejs &amp;&amp; apt install npm
</code></pre>
<p>然后执行 <code>node -v</code>和<code>npm -v</code>,看到输出就说明安装成功.<br>
然后鉴于apt默认源里NodeJs并非最新版,另外官方源速度太慢,我们可以安装NodeJs的版本管理器和软件源工具:</p>
<pre><code class="language-bash">npm cache clean --force #清除缓存
npm install -g n
npm install -g nrm
</code></pre>
<p>然后执行</p>
<pre><code class="language-bash">n stable # 安装最新稳定版
nrm use taobao # 将软件源设定为淘宝源(https://registry.npm.taobao.org/)
</code></pre>
<h3 id="windows下安装">Windows下安装</h3>
<p>由于种种原因并不推荐在Windows环境下直接安装NodeJs进行开发和调试<br>
<em>所以啊,亲爱的少年——</em><br>
<em>给我乖乖地装好WSL在Linux下code吧!</em><br>
<s>才不是我懒得在Windows下安装然后截图呢</s></p>
<h2 id="2-使用">.2 使用</h2>
<h3 id="nodejs-repl交互式环境">NodeJs REPL(交互式环境)</h3>
<p>NodeJs像Python一样提供了基于V8(不是Vtuber吧)引擎的交互式编程环境<br>
<s>真是开发的好工具呢(赞赏)</s><br>
在命令行环境下输入<code>node</code>即可进入REPL<br>
<s>推荐第一次进入REPL时执行<code>.1 + .2</code></s><br>
REPL中可以定义并启动服务器:</p>
<pre><code class="language-javascript">var http = require('http')
http.createServer(function(req, res){  
...    res.writeHead(200, {'Content-Type':'text/html'});
...    res.end('hello world');       
...  }).listen(8080, &quot;127.0.0.1&quot;)
</code></pre>
<p>此外,REPL还有一些基本的快捷键与命令:</p>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>C</kdb>: 退出当前终端</li>
<li>两次<kbd>Ctrl</kbd>+<kbd>C</kbd>: 退出REPL。</li>
<li><kbd>Ctrl</kbd>+<kbd>D</kbd>: 退出REPL.</li>
<li><kbd>↑</kbd>或<kbd>↓</kbd>: 查看历史命令</li>
<li><kbd>Tab</kbd>: 列出当前命令</li>
<li><code>.help</code> : 帮助</li>
<li><code>.break</code>: 退出多行表达式</li>
<li>.<code>clear</code>: 退出多行表达式</li>
<li><code>.save [name]</code>: 保存当前的 Node REPL 会话到指定文件,<em>[name]为文件名,可变</em></li>
<li><code>.load [name]</code>: 载入保存过的REPL会话的文件,<em>[name]为文件名,可变</em></li>
</ul>
<hr>
<h1 id="0x02-nodejs函数-回调函数与事件循环">0x02 Node.js函数、回调函数与事件循环</h1>
<h2 id="1-函数">.1 函数</h2>
<p>Node.js中的函数定义与JavaScript无异:</p>
<pre><code class="language-javascript">function myFunction(x) {
    return x * x;
}
</code></pre>
<p>特性(?)也与JavaScript类似:</p>
<pre><code class="language-javascript">function myFunction(x) {
    return x * x;
}

function debug(functionName, value) {
  functionName(value);
}

debug(myFunction,1);
debug(function(x){ return x * x},2);  //这是一个匿名函数
</code></pre>
<h2 id="2-回调函数">.2 回调函数</h2>
<h3 id="前置概念">前置概念</h3>
<blockquote>
<p>这里写的好乱...而且错误不断...等我过几天单独整理一篇文章出来,你可以暂时跳过这部分...</p>
</blockquote>
<p>在了解回调函数之前,我们先来复习一下同步/异步、阻塞/非阻塞和回调的概念:<br>
首先:</p>
<ul>
<li>A &quot;callback&quot; is any function that is called by another function which takes the first function as a parameter. (回调就是在一个函数中调用另一个函数)</li>
<li>JavaScript是一门<strong>单线程</strong>的语言,</li>
</ul>
<h4 id="同步异步">同步/异步</h4>
<p>同步的概念很好理解:  调用者主动等待这个调用的结果,例如:</p>
<pre><code class="language-javascript">function myFunction(x){
    console.log(x);
}

myFunction(&quot;Hello World!&quot;);
</code></pre>
<p>在你调用myFunction到输出&quot;Hello World!&quot;的这段时间,你在处理完毕之前等待系统处理这个调用,然后得到返回值.<br>
而异步则是调用后直接返回(没有返回数据),待到处理完通过状态或回调函数等通知调用者<br>
老师给我们举过这么一个例子:</p>
<blockquote>
<p>你打电话给书店老板,问这个月的《<s>知乎</s>故事汇》到了没,书店老板的回应方式:<br>
同步: &quot;我找找,你先别挂&quot;,然后开始找书,经过了可能是两秒,也可能是一天,找到了,在电话中回应你.<br>
异步: &quot;我找找,找到了给你打电话&quot;,然后开始找书,找到了之后电话通知你.</p>
</blockquote>
<p>所以同步和异步关注的是书店老板(被调用者)的状态.<br>
<em>异步函数必须指定回调函数,异步编程依托于回调函数实现</em></p>
<h4 id="阻塞非阻塞">阻塞/非阻塞</h4>
<p>还是书店老板的例子:<br>
在书店老板开始找书让你等着的时候,你选择了:</p>
<ul>
<li>阻塞: 等待直到老板通知你</li>
<li>非阻塞: 去做其他事情</li>
</ul>
<p>阻塞/非阻塞关注的是你(调用者)的状态<br>
<em>阻塞/非阻塞与同步/异步无关</em></p>
<p>前面提到过Node.js异步编程,而异步编程的直接体现就是回调函数,回调函数一般作为函数的最后一个参数.<br>
下面提供了一个非阻塞编程的实例:<br>
创建文件file.txt,内容如下:</p>
<pre><code>Hello World!!
</code></pre>
<p>app.js,内容如下:</p>
<pre><code class="language-javascript">const fs = require('fs');  //引入文件系统

fs.readFile('file.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});


console.log(&quot;Finish(?&quot;);
</code></pre>
<p>运行结果如下:</p>
<pre><code>&gt; node app.js
Finish(?
Hello World!!
</code></pre>
<p>不需要等待文件读取完,在读取文件时执行接下来的代码.</p>
<h2 id="3-事件循环">.3 事件循环</h2>
<p>当一个异步事件发生时,将会生成一个事件观察者,然后线程将进入一个类似while(true)的循环之中,直到没有事件观察者时退出.<br>
例子如下:</p>
<pre><code class="language-javascript">var events = require('events');
var eventEmitters = new events.EventEmitter();
var connectHandle = function connected(){
    console.log('再执行eventHandle');
    eventEmitters.emit('data-receive')
}

eventEmitters.on('data-receive',function(){
    console.log('最后接收数据');
})

eventEmitters.on('connection',connectHandle);
console.log('先执行connection');
eventEmitters.emit('connection');
console.log('程序处理完成');
</code></pre>
<h1 id="0x03-getpost请求">0x03 GET/POST请求</h1>
<blockquote>
<p>util模块下篇再介绍...(咕咕预定)</p>
</blockquote>
<h2 id="1-get请求">.1 GET请求:</h2>
<pre><code class="language-javascript">//引入模块
var http = require('http');
var url = require('url');
var util = require('util');
 
http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'}); //向请求写入相应头
    res.end(util.inspect(url.parse(req.url, true))); //解析URL内容
    var params = url.parse(req.url, true).query;
    res.write(params.a);
    res.end();
}).listen(8080);
</code></pre>
<p>你现在可以向<code>http://localhost:8080/?a=Hello World!</code>发送一个GET请求查看输出</p>
<h2 id="2-post请求">.2 POST请求</h2>
<pre><code class="language-javascript">var http = require('http');
var querystring = require('querystring');
var util = require('util');
 
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
 
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
 
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
}).listen(8080);
</code></pre>
<p><em>Node.js默认不会解析POST请求体</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Python装饰器]]></title>
        <id>https://www.geekore.ink/about-python-decorators/</id>
        <link href="https://www.geekore.ink/about-python-decorators/">
        </link>
        <updated>2021-02-06T03:08:45.000Z</updated>
        <content type="html"><![CDATA[<p>最近在研究FastAPI实现一个更易于操作的API框架.然后因为FastAPI的语法规则,每次都要写到<code>@app.get('')</code><br>
那么这个@开头的奇怪东西...我虽然知道是装饰器...可是怎么用...?</p>
<hr>
<h1 id="简单的装饰器">简单的装饰器</h1>
<p>比方说,你现在需要记录输出10000个数的时间,你可能会这么写:</p>
<pre><code class="language-python">import time

startTime = time.time()
for i in range(10000):
    print i
endTime = time.time()
print(endTime - startTime)
</code></pre>
<p>那么现在你需要记录快速排序10个数的时间,又是什么样的代码呢?</p>
<pre><code class="language-python">import time

def partition(arr,low,high): 
    i = ( low-1 )
    pivot = arr[high]     
  
    for j in range(low , high): 
        if   arr[j] &lt;= pivot: 
            i = i+1 
            arr[i],arr[j] = arr[j],arr[i] 
    arr[i+1],arr[high] = arr[high],arr[i+1] 
    return ( i+1 ) 

def quickSort(arr,low,high): 
    if low &lt; high: 
        pi = partition(arr,low,high) 
        quickSort(arr, low, pi-1) 
        quickSort(arr, pi+1, high) 
  
arr = [10,7,8,9,1,5,11,20,0,4] 
n = len(arr) 
startTime = time.time()
quickSort(arr,0,n-1) 
endTime = time.time()
for i in range(n): 
    print (&quot;%d&quot; %arr[i])
print(endTime - startTime)
</code></pre>
<p>问题来了,假如你有100个算法需要计算时间,你就需要改动每个脚本里的函数<br>
很麻烦对不对?<br>
这里,我们可以引入装饰器</p>
<blockquote>
<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。<br>
总的来讲,装饰器的功能就是在不改变函数或对象代码的情况下增添额外的功能.</p>
</blockquote>
<pre><code class="language-python">def timeDcrtr(func):
    def wrapper(*args,**kargs):
        startTime = time.time()
        f = func(*args,**kargs)
        endTime = time.time()
        execTime = endTime - startTime
        return f
    return wrapper
</code></pre>
<p>上面的代码展现了如何定义一个计算时间的装饰器,我们将它再次引入上文中输出10000个数字的代码:</p>
<pre><code class="language-python">import time

def timeDcrtr(func):
    def wrapper():
        startTime = time.time()
        f = func()
        endTime = time.time()
        execTime = endTime - startTime
        return f
    return wrapper

@timeDcrtr # @语法糖
for i in range(10000):
    print i
</code></pre>
<p>到这里,你已经实现了Python中最简单的装饰器功能.<br>
但是如果你要为装饰器传入参数怎么办?<br>
因为返回的函数并不能接受参数,你可以指定装饰器函数wrapper接受和原函数一样的参数:</p>
<pre><code class="language-python">def debug(func):
    def wrapper(something): #指定与下面output()函数一样的参数
        print &quot;enter {}()&quot;.format(func.__name__)
        return func()
    return wrapper

@debug
def output(something):
    print &quot;hello {}!&quot;.format(something)

</code></pre>
<p>但是问题又来了: debug装饰器在一个脚本里应用还好,可是你如果有100个脚本需要使用@debug呢?你需要手动修改每个脚本里的装饰器参数吗?<br>
别忘了python中的可变参数: <code>*args,**kwargs</code><br>
于是我们可以打造一个接受可变参数的装饰器:</p>
<pre><code class="language-python">def debug(func):
    def wrapper(*args,**kwargs): 
        print &quot;enter {}()&quot;.format(func.__name__)
        return func()
    return wrapper
</code></pre>
<h1 id="更高级的装饰器">更高级的装饰器</h1>
<p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出log信息,而且还需指定log的级别,那么装饰器就会是这样的:</p>
<pre><code class="language-python">def logging(level):
    def wrapper(func):
        def inner_wrapper(*args, **kwargs):
            print &quot;[{level}]: enter function {func}()&quot;.format(
                level=level,
                func=func.__name__)
            return func(*args, **kwargs)
        return inner_wrapper
    return wrapper

@logging(level='INFO')
def say(something):
    print &quot;say {}!&quot;.format(something)

# 如果没有使用@语法，等同于
# say = logging(level='INFO')(say)

@logging(level='DEBUG')
def do(something):
    print &quot;do {}...&quot;.format(something)

if __name__ == '__main__':
    say('hello')
    do(&quot;my work&quot;)
</code></pre>
<p>装饰器函数其实是这样一个接口约束它,必须接受一个callable对象作为参数，,然后返回一个callable对象.在Python中一般callable对象都是函数,但也有例外,只要某个对象重载了<code>__call__()</code>方法，那么这个对象就是callable的.<br>
装饰器要求接受一个callable对象,并返回一个callable对象.那么用类来实现也是也可以的.我们可以让类的构造函数<code>__init__()</code>接受一个函数,然后重载<code>__call__()</code>并返回一个函数,也可以达到装饰器函数的效果.</p>
<pre><code class="language-python">class logging(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print &quot;[DEBUG]: enter function {func}()&quot;.format(
            func=self.func.__name__)
        return self.func(*args, **kwargs)
@logging
def say(something):
    print &quot;say {}!&quot;.format(something)
</code></pre>
<hr>
<h1 id="小结">小结</h1>
<p>装饰器的理念是对原函数、对象的加强,相当于重新封装,所以一般装饰器函数都被命名为<code>wrapper()</code>,意义在于包装.函数只有在被调用时才会发挥其作用.比如<code>@logging</code>装饰器可以在函数执行时额外输出日志,<code>@cache</code>装饰过的函数可以缓存计算结果等等.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[嗯,Gridea真香]]></title>
        <id>https://www.geekore.ink/hello-world/</id>
        <link href="https://www.geekore.ink/hello-world/">
        </link>
        <updated>2021-02-05T04:31:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<blockquote>
<p>2020年4月24日建的站,一开始是Gridea,接着Wordpress,然后是Typecho,Gatsby,Jeklly,Hexo...最后换回了Gridea...<br>
能苟延残喘大半年也真是不容易呢(赞赏)</p>
</blockquote>
<hr>
<h1 id="正文">正文</h1>
<p>这篇文章我们还是来讨论一个老掉牙的问题:</p>
<blockquote>
<p>如何用Gridea搭建自己的网站?</p>
</blockquote>
<p>但是这次我们抛开技术上的问题,从另一个角度出发</p>
<h2 id="前期准备">前期准备</h2>
<blockquote>
<p>别头脑一热搭了自己的博客.<br>
(虽然用Github Pages好像并没有什么成本的说)</p>
</blockquote>
<p>大部分博客的文章数目都会在30-100篇左右停止,更多的是停在第一篇博文: 如何用Hexo搭建个人博客?<br>
所以在搭建自己的博客之前,想清楚你这个博客要写什么,怎么写,你所输出的内容有没有价值,能不能帮到他人.</p>
<p>然后你需要一台能够持久使用的电脑(别三天两头硬盘坏了换电脑了跑群里来问Gridea文件怎么同步),一个域名<s>和你的决心</s></p>
<p>Coding换了新版之后Gridea死活连不上...<br>
*我的决心碎了一地</p>
<h2 id="部署">部署</h2>
<p>(略)<br>
网上一堆教程我不赘述了啊...</p>
<h2 id="后期完善">后期完善</h2>
<p>你现在可以创作你自己的内容了,可是...</p>
<p>谁来看?</p>
<p>然后你需要做搜索引擎收录和SEO,做完之后终于有人来看了,这个时候你发现...</p>
<p>有人偷了我的文章?</p>
<p>你可能会应用一个协议(比如我现在正在用的协议CC-BY-NC-ND 4.0)</p>
<p>嗯,到这里,你这个博客才算能用</p>
<p>但是...</p>
<p>最重要的是,持续不断地输出有价值的内容.</p>
<p>以上.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://www.geekore.ink/hello-gridea/</id>
        <link href="https://www.geekore.ink/hello-gridea/">
        </link>
        <updated>2020-04-23T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>