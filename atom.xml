<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.geekore.ink</id>
    <title>KainHao的博客</title>
    <updated>2021-04-02T09:48:28.464Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.geekore.ink"/>
    <link rel="self" href="https://www.geekore.ink/atom.xml"/>
    <subtitle>一只咸鱼的博客</subtitle>
    <logo>https://www.geekore.ink/images/avatar.png</logo>
    <icon>https://www.geekore.ink/favicon.ico</icon>
    <rights>All rights reserved 2021, KainHao的博客</rights>
    <entry>
        <title type="html"><![CDATA[[谈资] | 聊聊未来的IT行业]]></title>
        <id>https://www.geekore.ink/tan-zi-or-liao-liao-wei-lai-de-it-xing-ye/</id>
        <link href="https://www.geekore.ink/tan-zi-or-liao-liao-wei-lai-de-it-xing-ye/">
        </link>
        <updated>2021-03-05T09:14:25.000Z</updated>
        <content type="html"><![CDATA[<p>大家好,这里是新栏目 '谈资'<br>
在这个栏目里, 我们不讲技术, 不谈实现, 从社会人文、经济市场的角度聊聊时事热点.</p>
<hr>
<p>今天是2021年3月5日,农历正月廿二,星期五.</p>
<p>1953年3月5日,斯大林于莫斯科病逝.</p>
<blockquote>
<p>他接过俄国时，俄国只有木犁；而当他撒手人寰时，俄国已拥有了原子弹。</p>
</blockquote>
<ol>
<li>中央气象台：今天到至6日较强冷空气将南下，降温直达广东，北方局地降温幅度可达16℃；</li>
<li>山东：全面放开城镇落户限制，将允许有农村宅基地的原进城落户农村人口回农村落户；</li>
<li>上海：推行房产中介人员实名从业制度，应主动出示实名信息卡，伪造信息卡将记入行业失信名单；</li>
<li>广东：启动人工耳蜗救助项目，重度听障患者最高可获3万元资助，有需求者可向当地残联申请；</li>
<li>江苏：明确教师不得用手机布置作业或要求学生利用手机完成作业；</li>
<li>广东：徐闻菠萝市场需求大增，菠萝价涨近3倍创历史新高；</li>
<li>3月4日晚新西兰北岛海域发生7.34级地震，官方发布海啸预警并要求民众紧急避险；</li>
<li>冰岛一周内发生万余次地震，冰岛气象局：近期可能有火山喷发。中使馆吁中国公民注意安全；</li>
<li>吉布提海域发生移民坠海事故，一艘载200人的偷渡船至少有20人被蛇头扔下船后溺水身亡，另有60人陷入困境；</li>
<li>4日印度安全部队人员遇反政府武装袭致3人身亡，另有2人受伤；</li>
<li>玻利维亚一巴士发生车祸并坠崖，造成至少21死26重伤；</li>
<li>外媒：法国通过落地许可，CGTN可继续在欧播出，包括英国；</li>
<li>外媒：瑞典发生涉嫌恐袭事件，8人被送往医院，其中有几人受重伤，警方：有人被斧头袭击；</li>
<li>日媒：为保证日本公众的安全，海外观众将被禁止入境日本观看奥运会。东京奥委会：将于3月底决定；日媒：日本海上自卫队罕见与西班牙海军联合训练，意在牵制中国；</li>
<li>韩国2020年的出生人口为27.2万人，创下历史最低，首次出现死亡大于出生的情况，韩媒：或成世界上首个消失的国家；</li>
<li>第十三届全国人民代表大会第四次会议今日开幕.</li>
</ol>
<hr>
<p>最近很意外地在群里遇到了阿里的大佬,简单聊了几句未来IT的发展方向</p>
<p><s>我何德何能...</s></p>
<p>他反复提到一个词: <code>DARQ</code>,简单来说,DARQ是这四样:</p>
<ul>
<li>分布式账本 (Distributed ledger)</li>
<li>人工智能 (AI)</li>
<li>扩展现实 (extended Reality)</li>
<li>量子计算 (Quantum Computing)</li>
</ul>
<p>首先，在当前产业结构升级和工业互联网快速发展的大背景下，IT行业的整体发展前景还是非常不错的，在发展趋势方面将体现出三个特点，其一是IT行业与传统行业的结合更加紧密；其二是IT行业整体的产业规模将进一步扩大；其三是IT行业将成为驱动创新的新动能。在产业互联网的影响下，IT行业与传统行业的结合将进入到一个新的阶段，大量的传统行业在产业互联网时代将通过网络化和智能化来实现生产效率的提升，同时IT行业将在产业互联网时代进一步整合大量的行业资源，为行业领域实现可持续发展提供支撑。从大的发展前景来看，产业互联网将全面重塑传统行业的产业体系，实现资源的合理配置和利用。工业互联网的发展和应用还能够为企业提供更加健壮的生产、运营环境，同时增强抵抗各种运营风险的能力。由于互联网正在从工具逐渐向生产材料过渡，所以IT行业整体的产业规模将进一步扩大，也会释放出大量的就业岗位。产业结构升级的一个重要基础是创新，而IT行业与传统行业的结合为传统行业提供了巨大的创新空间，所以IT行业也正在成为驱动传统行业创新的新动能。随着物联网和人工智能等技术的发展，未来大量的智能体将走进生产环境中，这个过程也将不断推动产业领域的创新步伐。最后，5G的落地应用对于工业互联网具有非常重要的意义，5G本身也会带动一个庞大的产业链，所以5G的落地应用将为IT行业打开一个新的发展篇章。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从0开始的分布式系统学习Day1]]></title>
        <id>https://www.geekore.ink/scalability-day1/</id>
        <link href="https://www.geekore.ink/scalability-day1/">
        </link>
        <updated>2021-02-19T02:20:08.000Z</updated>
        <content type="html"><![CDATA[<p><s>换到了Vercel,为什么觉得比GitHub Pages还慢</s></p>
<hr>
<h1 id="0x00-写在前面">0x00 写在前面</h1>
<p>这几篇文章可能更多注重分布式系统的操作,毕竟我可没胆子在MIT前面讲分布式233</p>
<h1 id="0x01-什么是分布式系统怎么衡量一个分布式系统的好坏">0x01 什么是分布式系统?怎么衡量一个分布式系统的好坏?</h1>
<p>提到分布式,在座的各位站长会想到什么?<br>
对,负载均衡和CDN.<br>
这是分布式最常见的应用,还有包括分布式灾备系统,分布式计算 <s>(我宣布,DCE天下第一)</s> 等都是<em>分布式</em>的应用.</p>
<p>概括地来说:<br>
分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。<br>
分布式是不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署在不同的服务器上，解决高并发的问题。<br>
集群是同一个业务部署在多台机器上，提高系统可用性。</p>
<p>那么怎么比较CloudFlare的CDN和腾讯云境内CDN呢?<br>
下面是几项衡量分布式系统的指标:</p>
<ul>
<li>性能. 性能包括吞吐量和响应时间.这两个指标常常是互相矛盾的,追求高吞吐的系统,往往很难做到低响应时间,反之亦然.</li>
<li>一致性(Consistency). 分布式系统中多台计算机中数据的一致性.</li>
<li>可用性(Availability). 在面对异常时仍然提供正常服务的能力</li>
<li>可扩展性(Scalability). 如果两台计算机构成的系统有两倍性能或者吞吐，就是可扩展性.</li>
</ul>
<h1 id="0x02-可扩展性可用性与一致性">0x02 可扩展性,可用性与一致性</h1>
<h2 id="1-可扩展性scalability">.1 可扩展性(Scalability)</h2>
<p>当一个系统 <s>被迫</s> 走向分布式的时候,可扩展性通常是最重要的理由.<br>
下面是一个例子:</p>
<blockquote>
<p>假如我经营的这个博客突然因为某篇文章火了起来,那么我需要的就不仅仅是Vercel和GitHub的免费托管. 我当然可以花时间把这套模板优化到极致,但更好的做法是,部署更多的Web服务器并利用CDN.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img.yunwuo.com/images/2021/02/22/be1b5a21ae01522006bc6caa69344a88.png" alt="一个典型的分布式系统就是CDN" loading="lazy"></figure>
<p>然而这个方法并不能无限提高服务的性能,因为瓶颈往往会出现在这里或那里,例如:</p>
<blockquote>
<p>这个博客是纯粹的静态网站,所以当然不需要利用数据库,可是假如这个网站是由PHP+MySQL构建的,那么在你增添了Web服务器后,瓶颈就出现在服务器与数据库的通信上——别忘了,我们还没有考虑到增加几台数据库.</p>
</blockquote>
<p>所以,有关扩展性是这样: 我们希望可以通过增加机器的方式来实现扩展,但是现实中这很难实现,需要一些架构设计来将这个可扩展性无限推进下去.</p>
<h2 id="2-可用性availability">.2 可用性(Availability)</h2>
<p>说到可用性,我推荐你先去买一本书:<br>
<img src="https://img.yunwuo.com/images/2021/02/22/6f252d189250e8c45a5c53131df1ecd7.png" alt="" loading="lazy"><br>
购买地址在这里: <a href="https://item.jd.com/53990252028.html">正版包邮5本李居明学风水的第一本书+大师教你看八字+看面相+看楼盘+姓名改运学 入门住宅玄学</a><br>
(京东,打钱!)<br>
当然,不是因为这事真的跟风水和玄学有什么关系,而是维持一个分布式系统的高可用实在太难了.<br>
当你有一台服务器或者电脑在运行的时候,通常错误很少或者根本不会发生错误,比如我手边这台2013年的MacBook Air. 它已经为我工作了七年,期间经受过我的种种折磨 <s>比如开虚拟机挖矿</s>,仍能正常启动并工作<br>
但是当你有1000台服务器的时候,问题常常会发生在意想不到的地方,一些罕见的错误也会被无限放大.即使每台服务器都可以稳定运行一年, 也意味着每天会有3台计算机出错.<br>
在讨论要如何解决这些问题之前,我们先来复习一下经常遇到的异常:</p>
<ul>
<li>服务器宕机. 内存错误,停电等都会导致宕机,此时节点被称为不可用.而宕机会导致内存丢失.</li>
<li>网络错误. 例如通信链路不可用,网络分区错误,响应超时等.</li>
<li>磁盘故障.<br>
所以在设计一个分布式系统时,必须一开始就考虑容错的问题.尽管容错的方法有很多,但其中有两个最核心的思想,即可用性(Availability)和自我恢复性(Recoverability).<br>
系统经过精心的设计,这样在特定的错误类型下,系统仍然能够正常运行,仍然可以像没有出现错误一样,为你提供完整的服务.<br>
对于一个具备可用性的系统,为了让系统在实际中具备应用意义,也需要具备可恢复性.因为可用的系统仅仅是在一定的故障范围内才可用,如果故障太多,可用系统也会停止工作,停止一切响应.但是当足够的故障被修复之后,系统还是需要能继续工作.所以,一个好的可用的系统,某种程度上应该也是可恢复的.当出现太多故障时,系统会停止响应,但是修复之后依然能正确运行.这是我们期望看到的.</li>
</ul>
<h2 id="3-一致性consistency">.3 一致性(Consistency)</h2>
<p>一致性通常被分为四个等级(由强至弱):</p>
<ul>
<li>Strict Consistency</li>
<li>Linearizable Consistency</li>
<li>Sequential Consistency</li>
<li>Causal Consistency(一般来讲,最弱)</li>
<li>Eventual Consistency(具体可参考MySQL的异步复制)<br>
在这篇文章中不讨论各个等级的原则,只简单说明强一致与弱一致各自的优劣.<br>
现在假设:</li>
</ul>
<blockquote>
<p>你有2000台运行数据库的服务器.假如使用强一致,当我对其中一台的数据库做修改时,这个系统可能要耗费几十秒乃至几分钟的时间在2000个节点中同步我的一次修改.<br>
因此强一致带来昂贵的通信问题,因为每次你执行put或者get请求,你都需要等待几十毫秒来与数据的两个副本通信,以确保它们都被更新了或者都被检查了以获得最新的数据.现在的处理器每秒可以执行数十亿条指令,等待几十毫秒会大大影响系统的处理速度.<br>
所以,人们常常会使用弱一致系统,你只需要更新最近的数据副本,并且只需要从最近的副本获取数据.</p>
</blockquote>
<h1 id="0x03-cap定理与base理论">0x03 CAP定理与BASE理论</h1>
<h2 id="1-cap定理">.1 CAP定理</h2>
<p><img src="https://img.yunwuo.com/images/2021/02/22/bffb0a10bc22bf2d5f1cd05e7c858683.png" alt="" loading="lazy"><br>
一致性(C): 在分布式系统中的所有数据备份,在同一时刻是否同样的值.(等同于所有节点访问同一份最新的数据副本)<br>
可用性(A): 保证每个请求不管成功或者失败都有响应.<br>
分区容忍性(P): 系统中任意信息的丢失或失败不会影响系统的继续运作.<br>
这个定理的特点在于C\A\P不可得兼,你只能选择其中的两个甚至一个.<br>
通常来说,容错(分区容忍性)是被优先考虑的,需要在CA中权衡.</p>
<h2 id="2-base理论">.2 BASE理论</h2>
<p>BASE理论强调:</p>
<ul>
<li>基本可用 (Basically Available)</li>
<li>软状态 (Soft State)</li>
<li>最终一致性 (Eventually Consistent)<br>
总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python json库]]></title>
        <id>https://www.geekore.ink/python-json/</id>
        <link href="https://www.geekore.ink/python-json/">
        </link>
        <updated>2021-02-12T10:04:05.000Z</updated>
        <content type="html"><![CDATA[<p>来介绍下Python中自带的一个库: json</p>
<hr>
<h1 id="引入">引入</h1>
<p>在你安装Python时json应已经被安装</p>
<pre><code class="language-python">import json
</code></pre>
<h1 id="编码">编码:</h1>
<p>语法:</p>
<pre><code class="language-python">json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)
</code></pre>
<p>实例:</p>
<pre><code class="language-python">import json

dataRaw = [ {'a':1,'b':2}]

data = json.dumps(dataRaw)
print(data)
</code></pre>
<h1 id="解码">解码</h1>
<p>语法:</p>
<pre><code class="language-python">json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])
</code></pre>
<p>实例:</p>
<pre><code class="language-python">import json

dataRaw = '{&quot;a&quot;:1,&quot;b&quot;:2}'

data = json.loads(dataRaw)
print(data)
</code></pre>
<hr>
<p>你还可以使用<code>json.load</code>和<code>json.dump</code>来处理和JSON相关的文件.</p>
<p><s>今日水文+1,不想写了就这样吧</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js初探]]></title>
        <id>https://www.geekore.ink/nodejs-1/</id>
        <link href="https://www.geekore.ink/nodejs-1/">
        </link>
        <updated>2021-02-12T09:59:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>Node.js,顾名思义,是基于Chrome V8引擎的异步/非阻塞JavaScript运行环境(解析器).<br>
讲简单点就是跑在服务器端的JavaScript.</p>
<hr>
<h1 id="0x01-安装与repl使用">0x01 安装与REPL使用</h1>
<h2 id="1-安装">.1 安装</h2>
<h3 id="linux下安装">Linux下安装</h3>
<p>用自带的包管理器安装即可.<br>
这里以Ubuntu 20.04 LTS为例:</p>
<pre><code class="language-bash">apt install nodejs &amp;&amp; apt install npm
</code></pre>
<p>然后执行 <code>node -v</code>和<code>npm -v</code>,看到输出就说明安装成功.<br>
然后鉴于apt默认源里NodeJs并非最新版,另外官方源速度太慢,我们可以安装NodeJs的版本管理器和软件源工具:</p>
<pre><code class="language-bash">npm cache clean --force #清除缓存
npm install -g n
npm install -g nrm
</code></pre>
<p>然后执行</p>
<pre><code class="language-bash">n stable # 安装最新稳定版
nrm use taobao # 将软件源设定为淘宝源(https://registry.npm.taobao.org/)
</code></pre>
<h3 id="windows下安装">Windows下安装</h3>
<p>由于种种原因并不推荐在Windows环境下直接安装NodeJs进行开发和调试<br>
<em>所以啊,亲爱的少年——</em><br>
<em>给我乖乖地装好WSL在Linux下code吧!</em><br>
<s>才不是我懒得在Windows下安装然后截图呢</s></p>
<h2 id="2-使用">.2 使用</h2>
<h3 id="nodejs-repl交互式环境">NodeJs REPL(交互式环境)</h3>
<p>NodeJs像Python一样提供了基于V8(不是Vtuber吧)引擎的交互式编程环境<br>
<s>真是开发的好工具呢(赞赏)</s><br>
在命令行环境下输入<code>node</code>即可进入REPL<br>
<s>推荐第一次进入REPL时执行<code>.1 + .2</code></s><br>
REPL中可以定义并启动服务器:</p>
<pre><code class="language-javascript">var http = require('http')
http.createServer(function(req, res){  
...    res.writeHead(200, {'Content-Type':'text/html'});
...    res.end('hello world');       
...  }).listen(8080, &quot;127.0.0.1&quot;)
</code></pre>
<p>此外,REPL还有一些基本的快捷键与命令:</p>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>C</kdb>: 退出当前终端</li>
<li>两次<kbd>Ctrl</kbd>+<kbd>C</kbd>: 退出REPL。</li>
<li><kbd>Ctrl</kbd>+<kbd>D</kbd>: 退出REPL.</li>
<li><kbd>↑</kbd>或<kbd>↓</kbd>: 查看历史命令</li>
<li><kbd>Tab</kbd>: 列出当前命令</li>
<li><code>.help</code> : 帮助</li>
<li><code>.break</code>: 退出多行表达式</li>
<li>.<code>clear</code>: 退出多行表达式</li>
<li><code>.save [name]</code>: 保存当前的 Node REPL 会话到指定文件,<em>[name]为文件名,可变</em></li>
<li><code>.load [name]</code>: 载入保存过的REPL会话的文件,<em>[name]为文件名,可变</em></li>
</ul>
<hr>
<h1 id="0x02-nodejs函数-回调函数与事件循环">0x02 Node.js函数、回调函数与事件循环</h1>
<h2 id="1-函数">.1 函数</h2>
<p>Node.js中的函数定义与JavaScript无异:</p>
<pre><code class="language-javascript">function myFunction(x) {
    return x * x;
}
</code></pre>
<p>特性(?)也与JavaScript类似:</p>
<pre><code class="language-javascript">function myFunction(x) {
    return x * x;
}

function debug(functionName, value) {
  functionName(value);
}

debug(myFunction,1);
debug(function(x){ return x * x},2);  //这是一个匿名函数
</code></pre>
<h2 id="2-回调函数">.2 回调函数</h2>
<h3 id="前置概念">前置概念</h3>
<blockquote>
<p>这里写的好乱...而且错误不断...等我过几天单独整理一篇文章出来,你可以暂时跳过这部分...</p>
</blockquote>
<p>在了解回调函数之前,我们先来复习一下同步/异步、阻塞/非阻塞和回调的概念:<br>
首先:</p>
<ul>
<li>A &quot;callback&quot; is any function that is called by another function which takes the first function as a parameter. (回调就是在一个函数中调用另一个函数)</li>
<li>JavaScript是一门<strong>单线程</strong>的语言,</li>
</ul>
<h4 id="同步异步">同步/异步</h4>
<p>同步的概念很好理解:  调用者主动等待这个调用的结果,例如:</p>
<pre><code class="language-javascript">function myFunction(x){
    console.log(x);
}

myFunction(&quot;Hello World!&quot;);
</code></pre>
<p>在你调用myFunction到输出&quot;Hello World!&quot;的这段时间,你在处理完毕之前等待系统处理这个调用,然后得到返回值.<br>
而异步则是调用后直接返回(没有返回数据),待到处理完通过状态或回调函数等通知调用者<br>
老师给我们举过这么一个例子:</p>
<blockquote>
<p>你打电话给书店老板,问这个月的《<s>知乎</s>故事汇》到了没,书店老板的回应方式:<br>
同步: &quot;我找找,你先别挂&quot;,然后开始找书,经过了可能是两秒,也可能是一天,找到了,在电话中回应你.<br>
异步: &quot;我找找,找到了给你打电话&quot;,然后开始找书,找到了之后电话通知你.</p>
</blockquote>
<p>所以同步和异步关注的是书店老板(被调用者)的状态.<br>
<em>异步函数必须指定回调函数,异步编程依托于回调函数实现</em></p>
<h4 id="阻塞非阻塞">阻塞/非阻塞</h4>
<p>还是书店老板的例子:<br>
在书店老板开始找书让你等着的时候,你选择了:</p>
<ul>
<li>阻塞: 等待直到老板通知你</li>
<li>非阻塞: 去做其他事情</li>
</ul>
<p>阻塞/非阻塞关注的是你(调用者)的状态<br>
<em>阻塞/非阻塞与同步/异步无关</em></p>
<p>前面提到过Node.js异步编程,而异步编程的直接体现就是回调函数,回调函数一般作为函数的最后一个参数.<br>
下面提供了一个非阻塞编程的实例:<br>
创建文件file.txt,内容如下:</p>
<pre><code>Hello World!!
</code></pre>
<p>app.js,内容如下:</p>
<pre><code class="language-javascript">const fs = require('fs');  //引入文件系统

fs.readFile('file.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});


console.log(&quot;Finish(?&quot;);
</code></pre>
<p>运行结果如下:</p>
<pre><code>&gt; node app.js
Finish(?
Hello World!!
</code></pre>
<p>不需要等待文件读取完,在读取文件时执行接下来的代码.</p>
<h2 id="3-事件循环">.3 事件循环</h2>
<p>当一个异步事件发生时,将会生成一个事件观察者,然后线程将进入一个类似while(true)的循环之中,直到没有事件观察者时退出.<br>
例子如下:</p>
<pre><code class="language-javascript">var events = require('events');
var eventEmitters = new events.EventEmitter();
var connectHandle = function connected(){
    console.log('再执行eventHandle');
    eventEmitters.emit('data-receive')
}

eventEmitters.on('data-receive',function(){
    console.log('最后接收数据');
})

eventEmitters.on('connection',connectHandle);
console.log('先执行connection');
eventEmitters.emit('connection');
console.log('程序处理完成');
</code></pre>
<h1 id="0x03-getpost请求">0x03 GET/POST请求</h1>
<blockquote>
<p>util模块下篇再介绍...(咕咕预定)</p>
</blockquote>
<h2 id="1-get请求">.1 GET请求:</h2>
<pre><code class="language-javascript">//引入模块
var http = require('http');
var url = require('url');
var util = require('util');
 
http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'}); //向请求写入相应头
    res.end(util.inspect(url.parse(req.url, true))); //解析URL内容
    var params = url.parse(req.url, true).query;
    res.write(params.a);
    res.end();
}).listen(8080);
</code></pre>
<p>你现在可以向<code>http://localhost:8080/?a=Hello World!</code>发送一个GET请求查看输出</p>
<h2 id="2-post请求">.2 POST请求</h2>
<pre><code class="language-javascript">var http = require('http');
var querystring = require('querystring');
var util = require('util');
 
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
 
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
 
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
}).listen(8080);
</code></pre>
<p><em>Node.js默认不会解析POST请求体</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Python装饰器]]></title>
        <id>https://www.geekore.ink/about-python-decorators/</id>
        <link href="https://www.geekore.ink/about-python-decorators/">
        </link>
        <updated>2021-02-06T03:08:45.000Z</updated>
        <content type="html"><![CDATA[<p>最近在研究FastAPI实现一个更易于操作的API框架.然后因为FastAPI的语法规则,每次都要写到<code>@app.get('')</code><br>
那么这个@开头的奇怪东西...我虽然知道是装饰器...可是怎么用...?</p>
<hr>
<h1 id="简单的装饰器">简单的装饰器</h1>
<p>比方说,你现在需要记录输出10000个数的时间,你可能会这么写:</p>
<pre><code class="language-python">import time

startTime = time.time()
for i in range(10000):
    print i
endTime = time.time()
print(endTime - startTime)
</code></pre>
<p>那么现在你需要记录快速排序10个数的时间,又是什么样的代码呢?</p>
<pre><code class="language-python">import time

def partition(arr,low,high): 
    i = ( low-1 )
    pivot = arr[high]     
  
    for j in range(low , high): 
        if   arr[j] &lt;= pivot: 
            i = i+1 
            arr[i],arr[j] = arr[j],arr[i] 
    arr[i+1],arr[high] = arr[high],arr[i+1] 
    return ( i+1 ) 

def quickSort(arr,low,high): 
    if low &lt; high: 
        pi = partition(arr,low,high) 
        quickSort(arr, low, pi-1) 
        quickSort(arr, pi+1, high) 
  
arr = [10,7,8,9,1,5,11,20,0,4] 
n = len(arr) 
startTime = time.time()
quickSort(arr,0,n-1) 
endTime = time.time()
for i in range(n): 
    print (&quot;%d&quot; %arr[i])
print(endTime - startTime)
</code></pre>
<p>问题来了,假如你有100个算法需要计算时间,你就需要改动每个脚本里的函数<br>
很麻烦对不对?<br>
这里,我们可以引入装饰器</p>
<blockquote>
<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。<br>
总的来讲,装饰器的功能就是在不改变函数或对象代码的情况下增添额外的功能.</p>
</blockquote>
<pre><code class="language-python">def timeDcrtr(func):
    def wrapper(*args,**kargs):
        startTime = time.time()
        f = func(*args,**kargs)
        endTime = time.time()
        execTime = endTime - startTime
        return f
    return wrapper
</code></pre>
<p>上面的代码展现了如何定义一个计算时间的装饰器,我们将它再次引入上文中输出10000个数字的代码:</p>
<pre><code class="language-python">import time

def timeDcrtr(func):
    def wrapper():
        startTime = time.time()
        f = func()
        endTime = time.time()
        execTime = endTime - startTime
        return f
    return wrapper

@timeDcrtr # @语法糖
for i in range(10000):
    print i
</code></pre>
<p>到这里,你已经实现了Python中最简单的装饰器功能.<br>
但是如果你要为装饰器传入参数怎么办?<br>
因为返回的函数并不能接受参数,你可以指定装饰器函数wrapper接受和原函数一样的参数:</p>
<pre><code class="language-python">def debug(func):
    def wrapper(something): #指定与下面output()函数一样的参数
        print &quot;enter {}()&quot;.format(func.__name__)
        return func()
    return wrapper

@debug
def output(something):
    print &quot;hello {}!&quot;.format(something)

</code></pre>
<p>但是问题又来了: debug装饰器在一个脚本里应用还好,可是你如果有100个脚本需要使用@debug呢?你需要手动修改每个脚本里的装饰器参数吗?<br>
别忘了python中的可变参数: <code>*args,**kwargs</code><br>
于是我们可以打造一个接受可变参数的装饰器:</p>
<pre><code class="language-python">def debug(func):
    def wrapper(*args,**kwargs): 
        print &quot;enter {}()&quot;.format(func.__name__)
        return func()
    return wrapper
</code></pre>
<h1 id="更高级的装饰器">更高级的装饰器</h1>
<p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出log信息,而且还需指定log的级别,那么装饰器就会是这样的:</p>
<pre><code class="language-python">def logging(level):
    def wrapper(func):
        def inner_wrapper(*args, **kwargs):
            print &quot;[{level}]: enter function {func}()&quot;.format(
                level=level,
                func=func.__name__)
            return func(*args, **kwargs)
        return inner_wrapper
    return wrapper

@logging(level='INFO')
def say(something):
    print &quot;say {}!&quot;.format(something)

# 如果没有使用@语法，等同于
# say = logging(level='INFO')(say)

@logging(level='DEBUG')
def do(something):
    print &quot;do {}...&quot;.format(something)

if __name__ == '__main__':
    say('hello')
    do(&quot;my work&quot;)
</code></pre>
<p>装饰器函数其实是这样一个接口约束它,必须接受一个callable对象作为参数，,然后返回一个callable对象.在Python中一般callable对象都是函数,但也有例外,只要某个对象重载了<code>__call__()</code>方法，那么这个对象就是callable的.<br>
装饰器要求接受一个callable对象,并返回一个callable对象.那么用类来实现也是也可以的.我们可以让类的构造函数<code>__init__()</code>接受一个函数,然后重载<code>__call__()</code>并返回一个函数,也可以达到装饰器函数的效果.</p>
<pre><code class="language-python">class logging(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print &quot;[DEBUG]: enter function {func}()&quot;.format(
            func=self.func.__name__)
        return self.func(*args, **kwargs)
@logging
def say(something):
    print &quot;say {}!&quot;.format(something)
</code></pre>
<hr>
<h1 id="小结">小结</h1>
<p>装饰器的理念是对原函数、对象的加强,相当于重新封装,所以一般装饰器函数都被命名为<code>wrapper()</code>,意义在于包装.函数只有在被调用时才会发挥其作用.比如<code>@logging</code>装饰器可以在函数执行时额外输出日志,<code>@cache</code>装饰过的函数可以缓存计算结果等等.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[嗯,Gridea真香]]></title>
        <id>https://www.geekore.ink/hello-world/</id>
        <link href="https://www.geekore.ink/hello-world/">
        </link>
        <updated>2021-02-05T04:31:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<blockquote>
<p>2020年4月24日建的站,一开始是Gridea,接着Wordpress,然后是Typecho,Gatsby,Jeklly,Hexo...最后换回了Gridea...<br>
能苟延残喘大半年也真是不容易呢(赞赏)</p>
</blockquote>
<hr>
<h1 id="正文">正文</h1>
<p>这篇文章我们还是来讨论一个老掉牙的问题:</p>
<blockquote>
<p>如何用Gridea搭建自己的网站?</p>
</blockquote>
<p>但是这次我们抛开技术上的问题,从另一个角度出发</p>
<h2 id="前期准备">前期准备</h2>
<blockquote>
<p>别头脑一热搭了自己的博客.<br>
(虽然用Github Pages好像并没有什么成本的说)</p>
</blockquote>
<p>大部分博客的文章数目都会在30-100篇左右停止,更多的是停在第一篇博文: 如何用Hexo搭建个人博客?<br>
所以在搭建自己的博客之前,想清楚你这个博客要写什么,怎么写,你所输出的内容有没有价值,能不能帮到他人.</p>
<p>然后你需要一台能够持久使用的电脑(别三天两头硬盘坏了换电脑了跑群里来问Gridea文件怎么同步),一个域名<s>和你的决心</s></p>
<p>Coding换了新版之后Gridea死活连不上...<br>
*我的决心碎了一地</p>
<h2 id="部署">部署</h2>
<p>(略)<br>
网上一堆教程我不赘述了啊...</p>
<h2 id="后期完善">后期完善</h2>
<p>你现在可以创作你自己的内容了,可是...</p>
<p>谁来看?</p>
<p>然后你需要做搜索引擎收录和SEO,做完之后终于有人来看了,这个时候你发现...</p>
<p>有人偷了我的文章?</p>
<p>你可能会应用一个协议(比如我现在正在用的协议CC-BY-NC-ND 4.0)</p>
<p>嗯,到这里,你这个博客才算能用</p>
<p>但是...</p>
<p>最重要的是,持续不断地输出有价值的内容.</p>
<p>以上.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://www.geekore.ink/hello-gridea/</id>
        <link href="https://www.geekore.ink/hello-gridea/">
        </link>
        <updated>2020-04-23T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>